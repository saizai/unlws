'use strict';
/** @typedef {(type: string, options: import("./custom.js").CustomOptions) => void} CustomOptions */

const stickyModule = (m => /* c8 ignore start */ m.__esModule ? m.default : m /* c8 ignore stop */)(require('sticky-module'));
const { $$ } = require('basic-devtools');

const { handle } = require('./script-handler.js');
const { assign } = require('./utils.js');
const { selectors, prefixes } = require('./interpreters.js');
const { listener, addAllListeners } = require('./listeners.js');

const {
    CUSTOM_SELECTORS,
    handleCustomType,
    customObserver: $customObserver,
    define: $define,
    whenDefined: $whenDefined
} = require('./custom.js');

const { env: $env } = require('./listeners.js');
const { Hook: $Hook, XWorker: $XWorker } = require('./xworker.js');

// avoid multiple initialization of the same library
const [
    {
        customObserver,
        define,
        whenDefined,
        env,
        Hook,
        XWorker
    },
    alreadyLive
] = stickyModule(
    'polyscript',
    {
        customObserver: $customObserver,
        define: $define,
        whenDefined: $whenDefined,
        env: $env,
        Hook: $Hook,
        XWorker: $XWorker
    }
);

exports.customObserver = customObserver;
exports.define = define;
exports.whenDefined = whenDefined;
exports.env = env;
exports.Hook = Hook;
exports.XWorker = XWorker;

(m => Object.keys(m).map(k => k !== 'default' && (exports[k] = m[k])))
(require('./errors.js'));


if (!alreadyLive) {
    const mo = new MutationObserver((records) => {
        const selector = selectors.join(',');
        for (const { type, target, attributeName, addedNodes } of records) {
            // attributes are tested via integration / e2e
            /* c8 ignore start */
            if (type === 'attributes') {
                const i = attributeName.lastIndexOf('-') + 1;
                if (i) {
                    const prefix = attributeName.slice(0, i);
                    for (const p of prefixes) {
                        if (prefix === p) {
                            const type = attributeName.slice(i);
                            if (type !== 'env') {
                                const method = target.hasAttribute(attributeName)
                                    ? 'add'
                                    : 'remove';
                                target[`${method}EventListener`](type, listener);
                            }
                            break;
                        }
                    }
                }
                continue;
            }
            for (const node of addedNodes) {
                if (node.nodeType === 1) {
                    addAllListeners(node);
                    if (selector && node.matches(selector)) handle(node);
                    else bootstrap(selector, node, true);
                }
            }
            /* c8 ignore stop */
        }
    });

    /* c8 ignore start */
    const bootstrap = (selector, node, shouldHandle) => {
        if (selector) $$(selector, node).forEach(handle);
        selector = CUSTOM_SELECTORS.join(',');
        if (selector) {
            if (shouldHandle) handleCustomType(node);
            $$(selector, node).forEach(handleCustomType);
        }
    };
    /* c8 ignore stop */

    const observe = (root) => {
        mo.observe(root, { childList: true, subtree: true, attributes: true });
        return root;
    };

    const { attachShadow } = Element.prototype;
    assign(Element.prototype, {
        attachShadow(init) {
            return observe(attachShadow.call(this, init));
        },
    });

    // give 3rd party a chance to apply changes before this happens
    queueMicrotask(() => {
        addAllListeners(observe(document));
        bootstrap(selectors.join(','), document, false);
    });

}
