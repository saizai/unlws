declare const _default: any;
export default _default;
declare class Jn extends Zn {
    constructor(e: any);
    readUint8Array(e: any, t: any): Promise<Uint8Array>;
}
declare class Yn extends Gn {
    constructor(e: any);
    blob: Promise<Blob>;
    getData(): Promise<Blob>;
}
declare class Kn extends Zn {
    constructor(e: any);
    readUint8Array(e: any, t: any): Uint8Array;
}
declare class Xn extends Vn {
    constructor(e: any);
    writeUint8Array(e: any): void;
    pending: any;
    getData(): string;
}
declare const Qr: "File format is not recognized";
declare const ti: "Central directory header not found";
declare const Ai: "File already exists";
declare const ii: "File contains encrypted entry";
declare const ei: "End of Zip64 central directory locator not found";
declare const $r: "End of central directory not found";
declare const ri: "Zip64 extra field not found";
declare const qn: "HTTP Range not supported";
declare const ji: "Zip file comment exceeds 64KB";
declare const Ei: "The strength must equal 1, 2, or 3";
declare const Di: "File entry comment exceeds 64KB";
declare const Ci: "File entry name exceeds 64KB";
declare const Ti: "Extra field data exceeds 64KB";
declare const Fi: "Extra field type exceeds 65535";
declare const ut: "Invalid password";
declare const pt: "Invalid signature";
declare const Ui: "Version exceeds 65535";
declare const Wn: "Writer iterator completed too soon";
declare const ni: "Local file header not found";
declare const oi: "Split zip file";
declare const Oi: "Undefined uncompressed size";
declare const ai: "Compression method not supported";
declare const si: "Encryption method not supported";
declare const Ri: "Zip64 is not supported (make sure 'keepOrder' is set to 'true')";
declare class mr extends pr {
}
declare class pr extends Zn {
    constructor(e: any, t?: {});
    set size(e: any);
    get size(): any;
    init(): Promise<void>;
    readUint8Array(e: any, t: any): any;
}
declare class Zn extends Gn {
    get readable(): ReadableStream<any>;
}
declare class gr extends Zn {
    constructor(e: any);
    readers: any;
    init(): Promise<void>;
    lastDiskNumber: any;
    lastDiskOffset: number;
    readUint8Array(e: any, t: any, n?: number): Promise<any>;
}
declare class xr extends Gn {
    constructor(e: any, t?: number);
}
declare const kr: typeof gr;
declare const zr: typeof xr;
declare class Qn extends Jn {
}
declare class $n extends Yn {
    getData(): Promise<any>;
}
declare class hr extends Zn {
    constructor(e: any);
    readUint8Array(e: any, t: any): any;
}
declare class wr extends Vn {
    init(e?: number): void;
    writeUint8Array(e: any): void;
    getData(): any;
}
declare class Vn extends Gn {
    writeUint8Array(): void;
}
declare class ui {
    constructor(e: any, t?: {});
    getEntriesGenerator(e?: {}): AsyncGenerator<Yr, boolean, unknown>;
    prependedData: any;
    comment: any;
    appendedData: any;
    getEntries(e?: {}): Promise<Yr[]>;
    close(): Promise<void>;
}
declare class pi {
    constructor(e?: {});
    readable: ReadableStream<any>;
    writable: WritableStream<any>;
}
declare class Mi {
    constructor(e: any, t?: {});
    add(e: string, t: any, n?: {}): Promise<Yr>;
    close(e?: Uint8Array, t?: {}): Promise<any>;
}
declare class Pi {
    constructor(e?: {});
    readable: ReadableStream<any>;
    zipWriter: Mi;
    transform(e: any): {
        readable: ReadableStream<any>;
        writable: WritableStream<any>;
    };
    writable(e: any): WritableStream<any>;
    close(e?: any, t?: {}): Promise<any>;
}
declare function Xe(e: any): void;
declare namespace ts {
    export { FS };
    export { es as ZipDirectoryEntry };
    export { $i as ZipFileEntry };
}
declare function $e(e: any): any;
declare function Tn(e: any, t: {}, n: any): {
    Deflate: {
        new (r: any): {
            codec: any;
            append(e: any): any;
            flush(): any;
        };
    };
    Inflate: {
        new (r: any): {
            codec: any;
            append(e: any): any;
            flush(): any;
        };
    };
};
declare function Fn(): Promise<void>;
declare class Gn {
    size: number;
    init(): void;
    initialized: boolean;
}
declare class Yr {
    constructor(e: any);
}
declare class FS {
    get children(): any;
    remove(e: any): void;
    move(e: any, t: any): void;
    find(e: any): any;
    getById(e: any): any;
    getChildByName(e: any): any;
    addDirectory(e: any, t: any): any;
    addText(e: any, t: any, n: any): any;
    addBlob(e: any, t: any, n: any): any;
    addData64URI(e: any, t: any, n: any): any;
    addUint8Array(e: any, t: any, n: any): any;
    addHttpContent(e: any, t: any, n: any): any;
    addReadable(e: any, t: any, n: any): any;
    addFileSystemEntry(e: any, t: any): any;
    addFileSystemHandle(e: any, t: any): any;
    addFile(e: any, t: any): any;
    addData(e: any, t: any): any;
    importBlob(e: any, t: any): any;
    importData64URI(e: any, t: any): any;
    importUint8Array(e: any, t: any): any;
    importHttpContent(e: any, t: any): any;
    importReadable(e: any, t: any): any;
    importZip(e: any, t: any): any;
    exportBlob(e: any): any;
    exportData64URI(e: any): any;
    exportUint8Array(e: any): any;
    exportWritable(e: any, t: any): any;
    isPasswordProtected(): any;
    checkPassword(e: any, t: any): Promise<any>;
}
declare class es extends Qi {
    directory: boolean;
    clone(e: any): es;
    addDirectory(e: any, t: any): $i | es;
    addText(e: any, t: any, n?: {}): $i | es;
    addBlob(e: any, t: any, n?: {}): $i | es;
    addData64URI(e: any, t: any, n?: {}): $i | es;
    addUint8Array(e: any, t: any, n?: {}): $i | es;
    addHttpContent(e: any, t: any, n?: {}): $i | es;
    addReadable(e: any, t: any, n?: {}): $i | es;
    addFileSystemEntry(e: any, t?: {}): Promise<any[]>;
    addFileSystemHandle(e: any, t?: {}): Promise<any[]>;
    addFile(e: any, t?: {}): $i | es;
    addData(e: any, t: any): $i | es;
    importBlob(e: any, t: any): Promise<($i | es)[]>;
    importData64URI(e: any, t: any): Promise<($i | es)[]>;
    importUint8Array(e: any, t: any): Promise<($i | es)[]>;
    importHttpContent(e: any, t: any): Promise<($i | es)[]>;
    importReadable(e: any, t: any): Promise<($i | es)[]>;
    exportBlob(e?: {}): Promise<any>;
    exportData64URI(e?: {}): Promise<any>;
    exportUint8Array(e?: {}): Promise<any>;
    exportWritable(e?: WritableStream<any>, t?: {}): Promise<WritableStream<any>>;
    importZip(e: any, t?: {}): Promise<($i | es)[]>;
    exportZip(e: any, t: any): Promise<any>;
    getChildByName(e: any): any;
    isPasswordProtected(): boolean;
    checkPassword(e: any, t?: {}): Promise<boolean>;
}
declare class $i extends Qi {
    Reader: any;
    Writer: any;
    getData(e: any, t?: {}): Promise<any>;
    clone(): $i;
    isPasswordProtected(): any;
    checkPassword(e: any, t?: {}): Promise<boolean>;
    getText(e: any, t: any): Promise<any>;
    getBlob(e: any, t: any): Promise<any>;
    getData64URI(e: any, t: any): Promise<any>;
    getUint8Array(e: any): Promise<any>;
    getWritable(e: WritableStream<any>, t: any): Promise<any>;
    replaceBlob(e: any): void;
    replaceText(e: any): void;
    replaceData64URI(e: any): void;
    replaceUint8Array(e: any): void;
    replaceReadable(e: any): void;
}
declare class Qi {
    constructor(e: any, t: any, n: any, r: any);
    moveTo(e: any): void;
    getFullname(): any;
    getRelativeName(e?: any): any;
    isDescendantOf(e: any): boolean;
    rename(e: any): void;
    name: any;
}
export { Jn as BlobReader, Yn as BlobWriter, Kn as Data64URIReader, Xn as Data64URIWriter, Qr as ERR_BAD_FORMAT, ti as ERR_CENTRAL_DIRECTORY_NOT_FOUND, Ai as ERR_DUPLICATED_NAME, ii as ERR_ENCRYPTED, ei as ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND, $r as ERR_EOCDR_NOT_FOUND, ri as ERR_EXTRAFIELD_ZIP64_NOT_FOUND, qn as ERR_HTTP_RANGE, ji as ERR_INVALID_COMMENT, Ei as ERR_INVALID_ENCRYPTION_STRENGTH, Di as ERR_INVALID_ENTRY_COMMENT, Ci as ERR_INVALID_ENTRY_NAME, Ti as ERR_INVALID_EXTRAFIELD_DATA, Fi as ERR_INVALID_EXTRAFIELD_TYPE, ut as ERR_INVALID_PASSWORD, pt as ERR_INVALID_SIGNATURE, Ui as ERR_INVALID_VERSION, Wn as ERR_ITERATOR_COMPLETED_TOO_SOON, ni as ERR_LOCAL_FILE_HEADER_NOT_FOUND, oi as ERR_SPLIT_ZIP_FILE, Oi as ERR_UNDEFINED_UNCOMPRESSED_SIZE, ai as ERR_UNSUPPORTED_COMPRESSION, si as ERR_UNSUPPORTED_ENCRYPTION, Ri as ERR_UNSUPPORTED_FORMAT, mr as HttpRangeReader, pr as HttpReader, Zn as Reader, gr as SplitDataReader, xr as SplitDataWriter, kr as SplitZipReader, zr as SplitZipWriter, Qn as TextReader, $n as TextWriter, hr as Uint8ArrayReader, wr as Uint8ArrayWriter, Vn as Writer, ui as ZipReader, pi as ZipReaderStream, Mi as ZipWriter, Pi as ZipWriterStream, Xe as configure, ts as fs, $e as getMimeType, Tn as initShimAsyncCodec, Fn as terminateWorkers };
